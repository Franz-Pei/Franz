export declare const File: {
    new (value?: any): {
        constructor: Function;
        toString(): string;
        toLocaleString(): string;
        valueOf(): Object;
        hasOwnProperty(v: PropertyKey): boolean;
        isPrototypeOf(v: Object): boolean;
        propertyIsEnumerable(v: PropertyKey): boolean;
    };
    getPrototypeOf(o: any): any;
    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
    getOwnPropertyNames(o: any): string[];
    create(o: object | null): any;
    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
    defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;
    defineProperties<T>(o: T, properties: PropertyDescriptorMap & ThisType<any>): T;
    seal<T>(o: T): T;
    freeze<T extends Function>(f: T): T;
    freeze<T extends {
        [idx: string]: U | null | undefined | object;
    }, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>;
    freeze<T>(o: T): Readonly<T>;
    preventExtensions<T>(o: T): T;
    isSealed(o: any): boolean;
    isFrozen(o: any): boolean;
    isExtensible(o: any): boolean;
    keys(o: object): string[];
    keys(o: {}): string[];
    assign<T extends {}, U>(target: T, source: U): T & U;
    assign<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;
    assign<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
    assign(target: object, ...sources: any[]): any;
    getOwnPropertySymbols(o: any): symbol[];
    is(value1: any, value2: any): boolean;
    setPrototypeOf(o: any, proto: object | null): any;
    values<T>(o: {
        [s: string]: T;
    } | ArrayLike<T>): T[];
    values(o: {}): any[];
    entries<T>(o: {
        [s: string]: T;
    } | ArrayLike<T>): [string, T][];
    entries(o: {}): [string, any][];
    getOwnPropertyDescriptors<T>(o: T): { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & {
        [x: string]: PropertyDescriptor;
    };
    fromEntries<T = any>(entries: Iterable<readonly [PropertyKey, T]>): {
        [k: string]: T;
    };
    fromEntries(entries: Iterable<readonly any[]>): any;
} | {
    new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;
    prototype: File;
};
declare const CFormInput: import("vue").DefineComponent<{
    /**
     * Toggle the disabled state for the component.
     */
    disabled: BooleanConstructor;
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedback: StringConstructor;
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedbackInvalid: StringConstructor;
    /**
     * Provide valuable, actionable invalid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    feedbackValid: StringConstructor;
    /**
     * Provide valuable, actionable valid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    floatingLabel: StringConstructor;
    /**
     * The id global attribute defines an identifier (ID) that must be unique in the whole document.
     */
    id: StringConstructor;
    /**
     * Set component validation state to invalid.
     */
    invalid: BooleanConstructor;
    /**
     * Add a caption for a component.
     *
     * @since 4.3.0
     */
    label: StringConstructor;
    /**
     * The default name for a value passed using v-model.
     */
    modelValue: (NumberConstructor | StringConstructor | {
        new (value?: any): {
            constructor: Function;
            toString(): string;
            toLocaleString(): string;
            valueOf(): Object;
            hasOwnProperty(v: PropertyKey): boolean;
            isPrototypeOf(v: Object): boolean;
            propertyIsEnumerable(v: PropertyKey): boolean;
        };
        getPrototypeOf(o: any): any;
        getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
        getOwnPropertyNames(o: any): string[];
        create(o: object | null): any;
        create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
        defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;
        defineProperties<T>(o: T, properties: PropertyDescriptorMap & ThisType<any>): T;
        seal<T>(o: T): T;
        freeze<T extends Function>(f: T): T;
        freeze<T extends {
            [idx: string]: U | null | undefined | object;
        }, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>;
        freeze<T>(o: T): Readonly<T>;
        preventExtensions<T>(o: T): T;
        isSealed(o: any): boolean;
        isFrozen(o: any): boolean;
        isExtensible(o: any): boolean;
        keys(o: object): string[];
        keys(o: {}): string[];
        assign<T extends {}, U>(target: T, source: U): T & U;
        assign<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;
        assign<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
        assign(target: object, ...sources: any[]): any;
        getOwnPropertySymbols(o: any): symbol[];
        is(value1: any, value2: any): boolean;
        setPrototypeOf(o: any, proto: object | null): any;
        values<T>(o: {
            [s: string]: T;
        } | ArrayLike<T>): T[];
        values(o: {}): any[];
        entries<T>(o: {
            [s: string]: T;
        } | ArrayLike<T>): [string, T][];
        entries(o: {}): [string, any][];
        getOwnPropertyDescriptors<T>(o: T): { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & {
            [x: string]: PropertyDescriptor;
        };
        fromEntries<T = any>(entries: Iterable<readonly [PropertyKey, T]>): {
            [k: string]: T;
        };
        fromEntries(entries: Iterable<readonly any[]>): any;
    } | {
        new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;
        prototype: File;
    })[];
    /**
     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use only along side `readonly`.
     */
    plainText: BooleanConstructor;
    /**
     * Toggle the readonly state for the component.
     */
    readonly: BooleanConstructor;
    /**
     * Size the component small or large.
     *
     * @values 'sm' | 'lg'
     */
    size: {
        type: StringConstructor;
        validator: (value: string) => boolean;
    };
    /**
     * Add helper text to the component.
     *
     * @since 4.3.0
     */
    text: StringConstructor;
    /**
     * Display validation feedback in a styled tooltip.
     *
     * @since 4.3.0
     */
    tooltipFeedback: BooleanConstructor;
    /**
     * Specifies the type of component.
     *
     * @values 'color' | 'file' | 'text' | string
     */
    type: {
        type: StringConstructor;
        default: string;
    };
    /**
     * Set component validation state to valid.
     */
    valid: BooleanConstructor;
}, () => import("vue").VNode<import("vue").RendererNode, import("vue").RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("input" | "change" | "update:modelValue")[], "input" | "change" | "update:modelValue", import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
    /**
     * Toggle the disabled state for the component.
     */
    disabled: BooleanConstructor;
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedback: StringConstructor;
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedbackInvalid: StringConstructor;
    /**
     * Provide valuable, actionable invalid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    feedbackValid: StringConstructor;
    /**
     * Provide valuable, actionable valid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    floatingLabel: StringConstructor;
    /**
     * The id global attribute defines an identifier (ID) that must be unique in the whole document.
     */
    id: StringConstructor;
    /**
     * Set component validation state to invalid.
     */
    invalid: BooleanConstructor;
    /**
     * Add a caption for a component.
     *
     * @since 4.3.0
     */
    label: StringConstructor;
    /**
     * The default name for a value passed using v-model.
     */
    modelValue: (NumberConstructor | StringConstructor | {
        new (value?: any): {
            constructor: Function;
            toString(): string;
            toLocaleString(): string;
            valueOf(): Object;
            hasOwnProperty(v: PropertyKey): boolean;
            isPrototypeOf(v: Object): boolean;
            propertyIsEnumerable(v: PropertyKey): boolean;
        };
        getPrototypeOf(o: any): any;
        getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
        getOwnPropertyNames(o: any): string[];
        create(o: object | null): any;
        create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
        defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;
        defineProperties<T>(o: T, properties: PropertyDescriptorMap & ThisType<any>): T;
        seal<T>(o: T): T;
        freeze<T extends Function>(f: T): T;
        freeze<T extends {
            [idx: string]: U | null | undefined | object;
        }, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>;
        freeze<T>(o: T): Readonly<T>;
        preventExtensions<T>(o: T): T;
        isSealed(o: any): boolean;
        isFrozen(o: any): boolean;
        isExtensible(o: any): boolean;
        keys(o: object): string[];
        keys(o: {}): string[];
        assign<T extends {}, U>(target: T, source: U): T & U;
        assign<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;
        assign<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
        assign(target: object, ...sources: any[]): any;
        getOwnPropertySymbols(o: any): symbol[];
        is(value1: any, value2: any): boolean;
        setPrototypeOf(o: any, proto: object | null): any;
        values<T>(o: {
            [s: string]: T;
        } | ArrayLike<T>): T[];
        values(o: {}): any[];
        entries<T>(o: {
            [s: string]: T;
        } | ArrayLike<T>): [string, T][];
        entries(o: {}): [string, any][];
        getOwnPropertyDescriptors<T>(o: T): { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & {
            [x: string]: PropertyDescriptor;
        };
        fromEntries<T = any>(entries: Iterable<readonly [PropertyKey, T]>): {
            [k: string]: T;
        };
        fromEntries(entries: Iterable<readonly any[]>): any;
    } | {
        new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;
        prototype: File;
    })[];
    /**
     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use only along side `readonly`.
     */
    plainText: BooleanConstructor;
    /**
     * Toggle the readonly state for the component.
     */
    readonly: BooleanConstructor;
    /**
     * Size the component small or large.
     *
     * @values 'sm' | 'lg'
     */
    size: {
        type: StringConstructor;
        validator: (value: string) => boolean;
    };
    /**
     * Add helper text to the component.
     *
     * @since 4.3.0
     */
    text: StringConstructor;
    /**
     * Display validation feedback in a styled tooltip.
     *
     * @since 4.3.0
     */
    tooltipFeedback: BooleanConstructor;
    /**
     * Specifies the type of component.
     *
     * @values 'color' | 'file' | 'text' | string
     */
    type: {
        type: StringConstructor;
        default: string;
    };
    /**
     * Set component validation state to valid.
     */
    valid: BooleanConstructor;
}>> & {
    onInput?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
}, {
    invalid: boolean;
    type: string;
    disabled: boolean;
    valid: boolean;
    tooltipFeedback: boolean;
    readonly: boolean;
    plainText: boolean;
}, {}>;
export { CFormInput };
