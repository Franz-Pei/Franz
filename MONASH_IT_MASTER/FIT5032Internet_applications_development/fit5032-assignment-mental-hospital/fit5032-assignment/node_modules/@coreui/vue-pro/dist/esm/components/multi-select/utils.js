const createOption = (label, options) => {
    const value = label.toLowerCase().replace(/\s/g, '-');
    let uniqueValue = value;
    let i = 1;
    while (options.some((option) => String(option.value) === uniqueValue)) {
        uniqueValue = `${value}-${i}`;
        i++;
    }
    return [
        {
            value: uniqueValue,
            label,
            custom: true,
        },
    ];
};
const filterOptionsList = (search, _options) => {
    if (search.length > 0 && _options) {
        const optionsList = [];
        for (const option of _options) {
            const options = option.options &&
                option.options.filter((option) => option.label && option.label.toLowerCase().includes(search.toLowerCase()));
            if ((option.label && option.label.toLowerCase().includes(search.toLowerCase())) ||
                (options && options.length > 0)) {
                optionsList.push(Object.assign({}, option, options && options.length > 0 && { options }));
            }
        }
        return optionsList;
    }
    return _options;
};
const flattenOptionsArray = (options, keepGroupLabel) => {
    const optionsList = [];
    for (const option of options) {
        if (Array.isArray(option.options)) {
            const { options, ...rest } = option;
            if (keepGroupLabel) {
                optionsList.push(rest);
            }
            optionsList.push(...options);
        }
        else {
            optionsList.push(option);
        }
    }
    return optionsList;
};
const getNextSibling = (elem, selector) => {
    // Get the next sibling element
    let sibling = elem.nextElementSibling;
    // If the sibling matches our selector, use it
    // If not, jump to the next sibling and continue the loop
    while (sibling) {
        if (sibling.matches(selector))
            return sibling;
        sibling = sibling.nextElementSibling;
    }
    return;
};
const getPreviousSibling = (elem, selector) => {
    // Get the next sibling element
    let sibling = elem.previousElementSibling;
    // If the sibling matches our selector, use it
    // If not, jump to the next sibling and continue the loop
    while (sibling) {
        if (sibling.matches(selector))
            return sibling;
        sibling = sibling.previousElementSibling;
    }
    return;
};
const selectOptions = (options, selected, deselected) => {
    let _selected = [...selected, ...options];
    if (deselected) {
        _selected = _selected.filter((selectedOption) => !deselected.some((deselectedOption) => deselectedOption.value === selectedOption.value));
    }
    const deduplicated = [];
    for (const option of _selected) {
        if (!deduplicated.some((obj) => obj.value === option.value)) {
            deduplicated.push(option);
        }
    }
    return deduplicated;
};

export { createOption, filterOptionsList, flattenOptionsArray, getNextSibling, getPreviousSibling, selectOptions };
//# sourceMappingURL=utils.js.map
